// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String               @id @default(cuid())
  firstName              String
  lastName               String
  email                  String               @unique
  password               String
  phone                  String
  ownedCompany           Company?             @relation("CompanyOwner")
  // Legacy: Keep for backward compatibility during migration
  company                Company?             @relation("CompanyEmployees", fields: [companyId], references: [id])
  companyId              String?
  // Many-to-many relationship: users can belong to multiple companies
  companyMemberships     CompanyMembership[]
  invitations            EmployeeInvitation[]
  personalRecipes        PersonalRecipe[]
  companyRecipesCreated  CompanyRecipe[]      @relation("CompanyRecipeCreator")
  isBlocked              Boolean              @default(false)
  isAdmin                Boolean              @default(false)
  emailVerificationToken String?
  emailVerified          Boolean              @default(false)
  emailVerifiedAt        DateTime?
  deletedAt              DateTime?            // Soft delete
  deletedBy              String?              // Who deleted (user ID)
  createdAt              DateTime             @default(now())
  updatedAt              DateTime             @updatedAt
}

model Company {
  id              String               @id @default(cuid())
  name            String
  address         String
  kvkNumber       String
  vatNumber       String?
  companyPhone    String?
  kvkDocumentPath String?
  kvkDocumentData String?              @db.Text // Base64 encoded document data (fallback storage)
  status          String               @default("pending") // pending, approved, rejected
  rejectionReason String?
  approvedAt      DateTime?
  approvedBy      String?
  owner           User                 @relation("CompanyOwner", fields: [ownerId], references: [id])
  ownerId         String               @unique
  // Legacy: Keep for backward compatibility during migration
  employees       User[]               @relation("CompanyEmployees")
  // Many-to-many relationship: companies can have multiple employees
  memberships     CompanyMembership[]
  invitations     EmployeeInvitation[]
  companyRecipes  CompanyRecipe[]
  deletedAt       DateTime?            // Soft delete
  deletedBy       String?              // Who deleted (user ID)
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
}

// Many-to-many relationship table for users and companies
model CompanyMembership {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  companyId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, companyId])
  @@index([userId])
  @@index([companyId])
}

model EmployeeInvitation {
  id            String   @id @default(cuid())
  email         String
  status        String   @default("pending") // pending, accepted, rejected
  company       Company  @relation(fields: [companyId], references: [id])
  companyId     String
  invitedBy     String? // User ID who sent the invitation
  invitedUser   User?    @relation(fields: [invitedUserId], references: [id])
  invitedUserId String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([companyId])
  @@index([email])
}

model Category {
  id              String           @id @default(cuid())
  name            String           @unique
  personalRecipes PersonalRecipe[] @relation("PersonalRecipeCategories")
  companyRecipes  CompanyRecipe[]  @relation("CompanyRecipeCategories")
}

// Personal recipes - completely isolated from company recipes
model PersonalRecipe {
  id           String               @id @default(cuid())
  name         String
  image        String?
  batchSize    Int?
  servings     Int?
  user         User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String // REQUIRED - personal recipes always belong to a user
  categories   Category[]           @relation("PersonalRecipeCategories")
  ingredients  PersonalIngredient[]
  instructions String?
  deletedAt    DateTime?            // Soft delete
  deletedBy    String?              // Who deleted (user ID)
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt

  @@index([userId, name])
  @@index([userId])
  @@index([deletedAt])
}

// Company recipes - completely isolated from personal recipes
model CompanyRecipe {
  id           String              @id @default(cuid())
  name         String
  image        String?
  batchSize    Int?
  servings     Int?
  company      Company             @relation(fields: [companyId], references: [id], onDelete: Cascade)
  companyId    String // REQUIRED - company recipes always belong to a company
  creator      User?               @relation("CompanyRecipeCreator", fields: [creatorId], references: [id], onDelete: SetNull)
  creatorId    String? // Track who created it, but company owns it
  categories   Category[]          @relation("CompanyRecipeCategories")
  ingredients  CompanyIngredient[]
  instructions String?
  deletedAt    DateTime?           // Soft delete
  deletedBy    String?             // Who deleted (user ID)
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt

  @@index([companyId, name])
  @@index([companyId])
  @@index([creatorId])
  @@index([deletedAt])
}

// Ingredients for personal recipes
model PersonalIngredient {
  id       String         @id @default(cuid())
  recipe   PersonalRecipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  recipeId String
  quantity Float
  unit     Unit
  name     String

  @@index([recipeId])
}

// Ingredients for company recipes
model CompanyIngredient {
  id       String        @id @default(cuid())
  recipe   CompanyRecipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  recipeId String
  quantity Float
  unit     Unit
  name     String

  @@index([recipeId])
}

enum Unit {
  stuks
  gram
  kg
  l
  ml
  personen
  portie
}

// Audit log for tracking all important actions
model AuditLog {
  id          String   @id @default(cuid())
  action      String   // create, update, delete, restore, etc.
  entityType  String   // User, Company, PersonalRecipe, CompanyRecipe, etc.
  entityId    String
  userId      String?  // Who performed the action
  userEmail   String?
  details     String?  @db.Text // JSON string with action details
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime @default(now())

  @@index([action])
  @@index([entityType])
  @@index([entityId])
  @@index([userId])
  @@index([createdAt])
}
